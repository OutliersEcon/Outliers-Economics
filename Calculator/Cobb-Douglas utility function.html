<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Cobb-Douglas Utility Simulator</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }

    body {
      max-width: 1200px;
      margin: 40px auto;
      padding: 20px;
      background-color: #f4f7fa;
      transition: background-color 0.3s, color 0.3s;
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
    }

    body.dark-mode {
      background-color: #1a1a1a;
      color: #e0e0e0;
    }

    .container {
      background-color: #fff;
      padding: 25px;
      border-radius: 10px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
      transition: background-color 0.3s, color 0.3s;
      position: relative;
      flex: 1;
      min-width: 300px;
      max-width: 700px;
    }

    body.dark-mode .container {
      background-color: #2c2c2c;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
    }

    .sidebar {
      background-color: #fff;
      padding: 25px;
      border-radius: 10px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
      transition: background-color 0.3s, color 0.3s;
      flex: 1;
      min-width: 300px;
      max-width: 400px;
    }

    body.dark-mode .sidebar {
      background-color: #2c2c2c;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
    }

    h2, h3 {
      color: #333;
      text-align: center;
      margin-bottom: 20px;
    }

    body.dark-mode h2, body.dark-mode h3 {
      color: #e0e0e0;
    }

    p {
      text-align: center;
      color: #555;
      margin-bottom: 20px;
    }

    body.dark-mode p {
      color: #adb5bd;
    }

    .sidebar p {
      text-align: left;
      margin-bottom: 15px;
    }

    .input-group {
      display: flex;
      align-items: center;
      margin-bottom: 20px;
    }

    label {
      width: 150px;
      font-weight: 500;
      color: #444;
    }

    body.dark-mode label {
      color: #e0e0e0;
    }

    input {
      flex: 1;
      padding: 10px;
      border: 1px solid #ccc;
      border-radius: 5px;
      font-size: 16px;
      transition: border-color 0.3s, background-color 0.3s, color 0.3s;
    }

    body.dark-mode input {
      background-color: #3a3a3a;
      border-color: #555;
      color: #e0e0e0;
    }

    input:focus {
      outline: none;
      border-color: #007bff;
    }

    input:invalid {
      border-color: #dc3545;
    }

    .button-group {
      display: flex;
      gap: 10px;
      justify-content: center;
      margin-bottom: 20px;
    }

    button {
      padding: 10px 20px;
      border: none;
      border-radius: 5px;
      font-size: 16px;
      cursor: pointer;
      transition: background-color 0.3s;
      color: #fff;
    }

    button:nth-child(1) {
      background-color: #28a745;
    }

    button:nth-child(1):hover {
      background-color: #218838;
    }

    button:nth-child(2) {
      background-color: #dc3545;
    }

    button:nth-child(2):hover {
      background-color: #c82333;
    }

    .zoom-button {
      background-color: #6c757d;
    }

    .zoom-button:hover {
      background-color: #5a6268;
    }

    #dark-mode-toggle {
      position: absolute;
      top: 15px;
      right: 15px;
      background-color: #6c757d;
      padding: 8px;
      font-size: 14px;
      width: 32px;
      height: 32px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      transition: background-color 0.3s, transform 0.2s;
    }

    #dark-mode-toggle:hover {
      background-color: #5a6268;
      transform: scale(1.1);
    }

    body.dark-mode #dark-mode-toggle {
      background-color: #adb5bd;
    }

    body.dark-mode #dark-mode-toggle:hover {
      background-color: #8f9ba6;
    }

    #results {
      padding: 15px;
      border: 1px solid #ddd;
      border-radius: 5px;
      background-color: #f8f9fa;
      margin: 20px 0;
      font-family: 'Courier New', Courier, monospace;
      font-size: 16px;
      text-align: left;
      transition: background-color 0.3s, border-color 0.3s, color 0.3s;
    }

    body.dark-mode #results {
      background-color: #3a3a3a;
      border-color: #555;
      color: #e0e0e0;
    }

    canvas {
      width: 100%;
      max-width: 600px;
      height: 400px;
      margin: 20px auto;
      display: block;
      border: 1px solid #ddd;
      border-radius: 5px;
      background-color: #fff;
      position: relative;
    }

    body.dark-mode canvas {
      border-color: #555;
      background-color: #2c2c2c;
    }

    .error {
      color: #dc3545;
      font-size: 14px;
      margin-top: 5px;
      display: none;
      text-align: center;
    }

    body.dark-mode .error {
      color: #ff6b6b;
    }

    #tooltip {
      position: absolute;
      background-color: rgba(0, 0, 0, 0.8);
      color: #fff;
      padding: 5px 10px;
      border-radius: 5px;
      font-size: 12px;
      pointer-events: none;
      display: none;
      left: 60px;
      top: 60px;
    }

    body.dark-mode #tooltip {
      background-color: rgba(255, 255, 255, 0.8);
      color: #333;
    }

    .math-formula {
      font-family: 'Courier New', Courier, monospace;
      background-color: #f1f3f5;
      padding: 10px;
      border-radius: 5px;
      margin-bottom: 15px;
      text-align: center;
    }

    body.dark-mode .math-formula {
      background-color: #3a3a3a;
      color: #e0e0e0;
    }

    @media (max-width: 768px) {
      body {
        margin: 20px auto;
        padding: 10px;
        flex-direction: column;
      }

      .container, .sidebar {
        max-width: 100%;
      }

      canvas {
        height: 300px;
      }

      #tooltip {
        left: 10px;
        top: 10px;
      }
    }

    @media (max-width: 480px) {
      .container, .sidebar {
        padding: 15px;
      }

      button {
        padding: 8px 16px;
        font-size: 14px;
      }

      #dark-mode-toggle {
        padding: 6px;
        width: 28px;
        height: 28px;
        font-size: 12px;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h2>Cobb-Douglas Utility Simulator</h2>
    <button id="dark-mode-toggle">☾</button>
    <p>Explore utility maximization with a Cobb-Douglas utility function and budget constraint.</p>

    <h3>Input Parameters</h3>
    <div class="input-group">
      <label for="income">Income (I):</label>
      <input type="number" id="income" min="0.01" step="0.01" value="100" required>
    </div>
    <div class="input-group">
      <label for="priceX">Price of Good X (Pₓ):</label>
      <input type="number" id="priceX" min="0.01" step="0.01" value="2" required>
    </div>
    <div class="input-group">
      <label for="priceY">Price of Good Y (Pᵧ):</label>
      <input type="number" id="priceY" min="0.01" step="0.01" value="4" required>
    </div>
    <div class="input-group">
      <label for="alpha">Alpha (α):</label>
      <input type="number" id="alpha" min="0.01" max="0.99" step="0.01" value="0.5" required>
    </div>

    <div class="error" id="inputError">Please enter valid positive numbers (0 < α < 1).</div>
    <div class="button-group">
      <button onclick="simulate()">Simulate</button>
      <button onclick="clearInput()">Clear</button>
      <button class="zoom-button" onclick="zoomChart(0.833)">Zoom In</button>
      <button class="zoom-button" onclick="zoomChart(1.2)">Zoom Out</button>
      <button class="zoom-button" onclick="autoFitZoom()">Auto-Fit</button>
    </div>

    <canvas id="utilityChart"></canvas>
    <div id="results"></div>
    <div id="tooltip"></div>
  </div>

  <div class="sidebar">
    <h3>About the Simulator</h3>
    <p><strong>Cobb-Douglas Utility Function:</strong> Represents consumer preferences with the form:</p>
    <div class="math-formula">
      U(X, Y) = Xᵅ * Y⁽¹⁻ᵅ⁾
    </div>
    <p><strong>Budget Constraint:</strong> Limits consumption based on income and prices:</p>
    <div class="math-formula">
      I = PₓX + PᵧY
    </div>
    <p><strong>Utility Maximization:</strong> The consumer chooses quantities of Good X and Good Y to maximize utility subject to the budget constraint. The optimal point occurs where the indifference curve is tangent to the budget line, satisfying:</p>
    <div class="math-formula">
      MRS = Pₓ/Pᵧ, where MRS = (α/(1-α)) * (Y/X)
    </div>
    <p><strong>Optimal Quantities:</strong> Derived as:</p>
    <div class="math-formula">
      X* = (α * I) / Pₓ, Y* = ((1-α) * I) / Pᵧ
    </div>
    <p><strong>Budget Line:</strong> Shows all combinations of X and Y affordable with income I.</p>
    <p><strong>Indifference Curve:</strong> Shows combinations of X and Y yielding the same utility level, tangent to the budget line at the optimal point.</p>
    <p><strong>Inputs:</strong></p>
    <ul>
      <li><strong>Income (I):</strong> Total budget for consumption.</li>
      <li><strong>Price of Good X (Pₓ):</strong> Price per unit of Good X.</li>
      <li><strong>Price of Good Y (Pᵧ):</strong> Price per unit of Good Y.</li>
      <li><strong>Alpha (α):</strong> Exponent in the utility function, between 0 and 1, representing preference for Good X.</li>
    </ul>
    <p><strong>Zoom:</strong> Use Zoom In/Out buttons to adjust the graph's viewable range. Auto-Fit adjusts to show the entire budget line and indifference curve.</p>
    <p><strong>Tooltip:</strong> Hover over the graph to see coordinates at the top-left corner.</p>
  </div>

  <script>
    let chartData = { xValues: [], yValues: [], optimalX: 0, optimalY: 0, utility: 0 };
    let zoom = { xMin: null, xMax: null, yMin: null, yMax: null };

    function simulate() {
      const income = parseFloat(document.getElementById('income').value);
      const priceX = parseFloat(document.getElementById('priceX').value);
      const priceY = parseFloat(document.getElementById('priceY').value);
      const alpha = parseFloat(document.getElementById('alpha').value);
      const inputError = document.getElementById('inputError');
      const resultElement = document.getElementById('results');

      // Validate inputs
      if (
        isNaN(income) || income <= 0 ||
        isNaN(priceX) || priceX <= 0 ||
        isNaN(priceY) || priceY <= 0 ||
        isNaN(alpha) || alpha <= 0 || alpha >= 1
      ) {
        inputError.style.display = 'block';
        resultElement.textContent = '';
        clearCanvas('utilityChart');
        chartData = { budgetPoints: [], indifferencePoints: [], optimalX: 0, optimalY: 0, utility: 0 };
        zoom = { xMin: null, xMax: null, yMin: null, yMax: null };
        return;
      } else {
        inputError.style.display = 'none';
      }

      // Calculate optimal quantities and utility
      const optimalX = (alpha * income) / priceX;
      const optimalY = ((1 - alpha) * income) / priceY;
      const utility = Math.pow(optimalX, alpha) * Math.pow(optimalY, 1 - alpha);

      // Generate budget line and indifference curve data
      chartData = calculateCurves(income, priceX, priceY, alpha, optimalX, optimalY, utility);
      chartData.optimalX = optimalX;
      chartData.optimalY = optimalY;
      chartData.utility = utility;

      // Initialize zoom if not set
      if (!zoom.xMax) {
        zoom = {
          xMin: 0,
          xMax: (income / priceX) * 1.5,
          yMin: 0,
          yMax: (income / priceY) * 1.5
        };
      }

      // Draw chart
      drawChart(chartData, income, priceX, priceY);

      // Display results
      resultElement.textContent = `Optimal Good X: ${optimalX.toFixed(2)}\n` +
                                 `Optimal Good Y: ${optimalY.toFixed(2)}\n` +
                                 `Utility Level: ${utility.toFixed(2)}`;
    }

    function calculateCurves(income, priceX, priceY, alpha, optimalX, optimalY, utility) {
      const xValues = [];
      const yValues = [];
      const steps = 100;
      const maxX = income / priceX;

      // Budget line: Y = (I - Px*X) / Py
      const budgetPoints = [];
      for (let i = 0; i <= steps; i++) {
        const x = (i / steps) * maxX;
        const y = (income - priceX * x) / priceY;
        budgetPoints.push({ x, y });
      }

      // Indifference curve: Y = (U / X^α)^(1/(1-α))
      const indifferencePoints = [];
      for (let i = 0; i <= steps; i++) {
        const x = (i / steps) * maxX;
        if (x === 0) continue; // Avoid division by zero
        const y = Math.pow(utility / Math.pow(x, alpha), 1 / (1 - alpha));
        indifferencePoints.push({ x, y });
      }

      return { budgetPoints, indifferencePoints, optimalX, optimalY, utility };
    }

    function drawChart(data, income, priceX, priceY) {
      const canvas = document.getElementById('utilityChart');
      const ctx = canvas.getContext('2d');

      // Clear canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Set canvas size
      canvas.width = canvas.offsetWidth;
      canvas.height = canvas.offsetHeight;

      const padding = 50;
      const xMin = zoom.xMin;
      const xMax = zoom.xMax;
      const yMin = zoom.yMin;
      const yMax = zoom.yMax;
      const width = canvas.width - 2 * padding;
      const height = canvas.height - 2 * padding;

      // Draw axes
      ctx.beginPath();
      ctx.moveTo(padding, padding);
      ctx.lineTo(padding, canvas.height - padding);
      ctx.lineTo(canvas.width - padding, canvas.height - padding);
      ctx.strokeStyle = document.body.classList.contains('dark-mode') ? '#e0e0e0' : '#333';
      ctx.stroke();

      // Draw labels
      ctx.fillStyle = document.body.classList.contains('dark-mode') ? '#e0e0e0' : '#333';
      ctx.font = '12px Segoe UI';
      ctx.textAlign = 'center';
      ctx.fillText('Good X', canvas.width / 2, canvas.height - padding + 40);
      ctx.textAlign = 'right';
      ctx.fillText('Good Y', padding - 10, padding - 10);

      // Draw ticks and labels
      for (let i = 0; i <= 5; i++) {
        const x = padding + (i / 5) * width;
        const y = canvas.height - padding - (i / 5) * height;
        const xValue = xMin + (i / 5) * (xMax - xMin);
        const yValue = yMin + (i / 5) * (yMax - yMin);
        ctx.fillText(xValue.toFixed(1), x, canvas.height - padding + 15);
        ctx.fillText(yValue.toFixed(1), padding - 10, y + 5);
      }

      // Draw budget line
      ctx.beginPath();
      let started = false;
      for (let point of data.budgetPoints) {
        if (point.x < xMin || point.x > xMax || point.y < yMin || point.y > yMax) continue;
        const x = padding + ((point.x - xMin) / (xMax - xMin)) * width;
        const y = canvas.height - padding - ((point.y - yMin) / (yMax - yMin)) * height;
        if (!started) {
          ctx.moveTo(x, y);
          started = true;
        } else {
          ctx.lineTo(x, y);
        }
      }
      ctx.strokeStyle = 'red';
      ctx.stroke();

      // Draw indifference curve
      ctx.beginPath();
      started = false;
      for (let point of data.indifferencePoints) {
        if (point.x < xMin || point.x > xMax || point.y < yMin || point.y > yMax) continue;
        const x = padding + ((point.x - xMin) / (xMax - xMin)) * width;
        const y = canvas.height - padding - ((point.y - yMin) / (yMax - yMin)) * height;
        if (!started) {
          ctx.moveTo(x, y);
          started = true;
        } else {
          ctx.lineTo(x, y);
        }
      }
      ctx.strokeStyle = '#28a745';
      ctx.stroke();

      // Draw optimal point
      const optX = padding + ((data.optimalX - xMin) / (xMax - xMin)) * width;
      const optY = canvas.height - padding - ((data.optimalY - yMin) / (yMax - yMin)) * height;
      if (
        data.optimalX >= xMin && data.optimalX <= xMax &&
        data.optimalY >= yMin && data.optimalY <= yMax
      ) {
        ctx.beginPath();
        ctx.arc(optX, optY, 5, 0, 2 * Math.PI);
        ctx.fillStyle = 'blue';
        ctx.fill();
      }
    }

    function zoomChart(factor) {
      const xRange = zoom.xMax - zoom.xMin;
      const yRange = zoom.yMax - zoom.yMin;
      const xMid = (zoom.xMin + zoom.xMax) / 2;
      const yMid = (zoom.yMin + zoom.yMax) / 2;

      const newXRange = xRange * factor;
      const newYRange = yRange * factor;
      zoom.xMin = Math.max(0, xMid - newXRange / 2);
      zoom.xMax = xMid + newXRange / 2;
      zoom.yMin = Math.max(0, yMid - newYRange / 2);
      zoom.yMax = yMid + newYRange / 2;

      drawChart(chartData, parseFloat(document.getElementById('income').value),
                parseFloat(document.getElementById('priceX').value),
                parseFloat(document.getElementById('priceY').value));
    }

    function autoFitZoom() {
      const income = parseFloat(document.getElementById('income').value);
      const priceX = parseFloat(document.getElementById('priceX').value);
      const priceY = parseFloat(document.getElementById('priceY').value);
      const alpha = parseFloat(document.getElementById('alpha').value);

      // Validate inputs to avoid proceeding with invalid data
      if (
        isNaN(income) || income <= 0 ||
        isNaN(priceX) || priceX <= 0 ||
        isNaN(priceY) || priceY <= 0 ||
        isNaN(alpha) || alpha <= 0 || alpha >= 1
      ) {
        return; // Silently return if inputs are invalid
      }

      // Calculate maximum X and Y from budget line
      const maxX = income / priceX; // X-intercept of budget line
      const maxY = income / priceY; // Y-intercept of budget line

      // Calculate max Y on indifference curve at x = maxX/2 (to capture curve's extent)
      const optimalX = (alpha * income) / priceX;
      const optimalY = ((1 - alpha) * income) / priceY;
      const utility = Math.pow(optimalX, alpha) * Math.pow(optimalY, 1 - alpha);
      const midX = maxX / 2;
      const maxYIndifference = Math.pow(utility / Math.pow(midX, alpha), 1 / (1 - alpha));

      // Set zoom with padding (1.2x for visibility)
      zoom = {
        xMin: 0,
        xMax: maxX * 1.2,
        yMin: 0,
        yMax: Math.max(maxY, maxYIndifference) * 1.2
      };

      // Redraw chart
      drawChart(chartData, income, priceX, priceY);
    }

    function clearInput() {
      document.getElementById('income').value = '100';
      document.getElementById('priceX').value = '2';
      document.getElementById('priceY').value = '4';
      document.getElementById('alpha').value = '0.5';
      document.getElementById('inputError').style.display = 'none';
      document.getElementById('results').textContent = '';
      clearCanvas('utilityChart');
      chartData = { budgetPoints: [], indifferencePoints: [], optimalX: 0, optimalY: 0, utility: 0 };
      zoom = { xMin: null, xMax: null, yMin: null, yMax: null };
    }

    function clearCanvas(canvasId) {
      const canvas = document.getElementById(canvasId);
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      document.getElementById('tooltip').style.display = 'none';
    }

    function toggleDarkMode() {
      document.body.classList.toggle('dark-mode');
      const toggleButton = document.getElementById('dark-mode-toggle');
      toggleButton.textContent = document.body.classList.contains('dark-mode') ? '☀' : '☾';
      simulate();
    }

    function showTooltip(event) {
      if (!chartData.budgetPoints.length) return;

      const canvas = document.getElementById('utilityChart');
      const tooltip = document.getElementById('tooltip');
      const rect = canvas.getBoundingClientRect();
      const mouseX = event.clientX - rect.left;
      const mouseY = event.clientY - rect.top;

      const padding = 50;
      const xMin = zoom.xMin;
      const xMax = zoom.xMax;
      const yMin = zoom.yMin;
      const yMax = zoom.yMax;
      const width = canvas.width - 2 * padding;
      const height = canvas.height - 2 * padding;

      const x = xMin + (mouseX - padding) / width * (xMax - xMin);
      const y = yMax - (mouseY - padding) / height * (yMax - yMin);

      // Find closest point (checking both curves)
      let minDist = Infinity;
      let closestPoint = null;
      let curveType = '';

      // Check budget line points
      for (let point of chartData.budgetPoints) {
        const canvasX = padding + ((point.x - xMin) / (xMax - xMin)) * width;
        const canvasY = canvas.height - padding - ((point.y - yMin) / (yMax - yMin)) * height;
        const dist = Math.hypot(canvasX - mouseX, canvasY - mouseY);
        if (dist < minDist && dist < 10) {
          minDist = dist;
          closestPoint = point;
          curveType = 'Budget Line';
        }
      }

      // Check indifference curve points
      for (let point of chartData.indifferencePoints) {
        const canvasX = padding + ((point.x - xMin) / (xMax - xMin)) * width;
        const canvasY = canvas.height - padding - ((point.y - yMin) / (yMax - yMin)) * height;
        const dist = Math.hypot(canvasX - mouseX, canvasY - mouseY);
        if (dist < minDist && dist < 10) {
          minDist = dist;
          closestPoint = point;
          curveType = 'Indifference Curve';
        }
      }

      // Check optimal point
      const optCanvasX = padding + ((chartData.optimalX - xMin) / (xMax - xMin)) * width;
      const optCanvasY = canvas.height - padding - ((chartData.optimalY - yMin) / (yMax - yMin)) * height;
      const optDist = Math.hypot(optCanvasX - mouseX, optCanvasY - mouseY);
      if (optDist < minDist && optDist < 10) {
        closestPoint = { x: chartData.optimalX, y: chartData.optimalY };
        curveType = 'Optimal Point';
      }

      if (closestPoint) {
        tooltip.style.display = 'block';
        tooltip.textContent = `${curveType}: X = ${closestPoint.x.toFixed(2)}, Y = ${closestPoint.y.toFixed(2)}`;
      } else {
        tooltip.style.display = 'none';
      }
    }

    // Event listeners
    document.getElementById('dark-mode-toggle').addEventListener('click', toggleDarkMode);
    document.getElementById('income').addEventListener('input', simulate);
    document.getElementById('priceX').addEventListener('input', simulate);
    document.getElementById('priceY').addEventListener('input', simulate);
    document.getElementById('alpha').addEventListener('input', simulate);
    document.getElementById('utilityChart').addEventListener('mousemove', showTooltip);
    document.getElementById('utilityChart').addEventListener('mouseleave', () => {
      document.getElementById('tooltip').style.display = 'none';
    });

    // Initial simulation
    simulate();
  </script>
</body>
</html>